### 伪代码
**信号量初始化**
```
semaphore mutex = 1;      // 确保发送线程和接收线程不会同时访问共享缓冲区，它是二元信号量，初始为 1
semaphore empty = N;      // 计算可用的单元数量，初始为缓冲区的大小
semaphore full = 0;       // 统计缓冲区被占用的单元数量，初始为 0
```

**生产者 (send) 逻辑**
```
send(message msg) {
    // 检查是否有空位(P操作)
    // 如果 empty > 0，则 empty 减 1，继续执行
    // 如果 empty == 0，则生产者线程阻塞，等待唤醒
    down(empty);

    // 锁住缓冲区 (P操作)
    down(mutex);

    // 向缓冲区添加新物品
    buffer[in % N] = msg;
    in = in + 1;

    // 解锁缓冲区 (V操作)
    up(mutex);

    // 通知消费者有新产品了 (V操作)
    // full 加 1。如果之前有消费者因 full==0 而阻塞，则唤醒它
    up(full);
}
```

**消费者 (receive) 逻辑**
```
message receive() {
    // 是否有产品(P操作)
    // 如果 full > 0，则 full 减 1，继续执行
    // 如果 full == 0，则消费者线程阻塞，等待唤醒
    down(full);

    // 锁住缓冲区 (P操作)
    down(mutex);

    // 从缓冲区取出物品
    msg = buffer[out % N];
    out = out + 1;

    // 解锁缓冲区 (V操作)
    up(mutex);

    // 通知生产者有空位了 (V操作)
    // empty 加 1。如果之前有生产者因 empty==0 而阻塞，则唤醒它
    up(empty);

    return msg;
}
```