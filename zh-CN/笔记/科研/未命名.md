 - 旋转矩阵到底是什么？
    可以把三维向量 (x, y, z) 看成一列数。一个 3×3 的旋转矩阵 R，乘在向量左边 R @ v，就相当于把这
  个向量绕原点做了“纯旋转”。
      - 旋转的特点：长度不变、夹角不变，所以 R 的列向量彼此正交、且模长都是 1。
      - 例子：绕 z 轴逆时针 90° 的矩阵
        [
        R = \begin{bmatrix} 0 & -1 & 0 \ 1 & 0 & 0 \ 0 & 0 & 1 \end{bmatrix}
        ]
        你把 (1, 0, 0) 乘进去，就变成 (0, 1, 0)——确实是绕 z 轴转了 90°。
  - determinant（行列式）为什么重要？
    对 3D 旋转矩阵来说，determinant 只有两个可能：+1 或 -1。
      - +1：说明它确实只是旋转，没有镜像翻转（右手系 → 右手系）。
      - -1：说明里面夹了一个反射（镜像），也就是左手系或镜面翻转。
        Umeyama 原始推导假设我们要找的是 det=+1 的“真正旋转矩阵”，所以在 SVD 结果 det<0 时，需要
  把最后一个奇异向量翻过去（diag[-1] = -1）来消除反射。
  - 怎么理解“左手系/右手系”？
    如果你拿右手，食指指 x 轴正方向，中指指 y 轴正方向，拇指自然指向 z 轴正方向，这就是右手系。
      - 在右手系里，x × y = z。
      - 如果某个坐标系里 x × y = -z，那么它是左手系。
        右手系常见于大多数 3D 图形库、PyTorch3D 等；左手系常见于部分图形 API（例如一些 DirectX
  设定）。如果你用的是右手系，Umeyama 的 det=+1 约束就是对的；如果实际数据带了镜像（左手→右
  手），就需要额外处理。
  - “谁乘谁”的顺序怎么记？
    约定我们用“列向量”写法，即向量是 3×1，旋转矩阵是 3×3，写作 R @ v。
      - 如果是点乘矩阵右边（v @ R^T），其实得到的结果一样，因为 R @ v 和 v @ R^T 是等价的，只是
  写法不同。
      - 在 PyTorch、NumPy 中，我们通常用 R @ v 或 (points @ R.T)。代码里看到的 scale * (points @
  rotation.transpose(0, 1)) + translation，正是这个意思：先旋转再平移。
  - 我们当前 _umeyama_alignment 里面做的事情
      1. 对点云做中心化（减去均值）。
      2. 算协方差矩阵 cov = Yᵀ @ X / N。
      3. SVD 分解 cov = U Σ Vᵀ。
      4. 如果 det(UVᵀ) < 0，把 diag = [1, 1, -1] 乘进去，以保证最终 rot = U diag Vᵀ 行列式
  为 +1。
      5. 用 Umeyama 公式求缩放 scale = Σ·diag / var_x，再求平移 translation = μ_y - scale*(R
  μ_x)。
      6. 把结果 cast 回原 dtype。

    这完全是标准的 Umeyama，相当“纯粹”。用双精度只是防止 SVD 偶尔在 float32 下收敛不好，对算法本
  身没有影响。

  如果你不确定自己的点云是不是有镜像，可以做个简单检查：选一组基向量或相机的 right/up/forward，
  算它们的向量积，看结果的方向是否符合右手系；或直接在 TensorBoard 看我们现在的可视化：黄色对应
  点已经和绿色 GT 重合，说明对应集合没偏；若蓝色和红色差很多，多半是预测点云本身就偏了（模型输出
  的问题），或者对应关系不一一匹配，而不是 Umeyama 算错。

  总之，不需要纠结“神秘修正”；当前代码就是经典 Umeyama。如果还担心，可告诉我你希望看到的具体数学
  形式，我可以整理成一页小笔记。